<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/de/ben/FileCopy.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/ben/FileCopy.java" />
              <option name="originalContent" value="package de.ben;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.IOException;&#10;import java.io.InputStream;&#10;import java.io.OutputStream;&#10;import java.nio.file.FileVisitResult;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.SimpleFileVisitor;&#10;import java.nio.file.attribute.BasicFileAttributes;&#10;import java.nio.file.StandardCopyOption;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Objects;&#10;import java.util.concurrent.ExecutionException;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.Future;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Robust, production-ready directory copier with focus on stability and security.&#10; */&#10;public final class FileCopy {&#10;&#10;    private static final Logger LOG = LoggerFactory.getLogger(FileCopy.class);&#10;&#10;    private FileCopy() {&#10;        // utility class&#10;    }&#10;&#10;    /**&#10;     * Copy a directory recursively from source to target using a thread pool.&#10;     */&#10;    public static void copyDirectory(Path source, Path target, int threads) throws IOException, InterruptedException {&#10;        Objects.requireNonNull(source, &quot;source&quot;);&#10;        Objects.requireNonNull(target, &quot;target&quot;);&#10;&#10;        if (threads &lt;= 0) throw new IllegalArgumentException(&quot;threads must be &gt;= 1&quot;);&#10;&#10;        // Normalize once and bind to final locals so inner classes/lambdas can reference them&#10;        final Path src = source.toAbsolutePath().normalize();&#10;        final Path tgt = target.toAbsolutePath().normalize();&#10;&#10;        if (!Files.exists(src)) throw new IOException(&quot;Source does not exist: &quot; + src);&#10;        if (!Files.isDirectory(src)) throw new IOException(&quot;Source is not a directory: &quot; + src);&#10;&#10;        // Ensure target exists&#10;        if (!Files.exists(tgt)) {&#10;            Files.createDirectories(tgt);&#10;        }&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        List&lt;Future&lt;Void&gt;&gt; futures = new ArrayList&lt;&gt;();&#10;&#10;        try {&#10;            // Schedule copy tasks&#10;            scheduleCopyTasks(src, tgt, executor, futures);&#10;&#10;            // Prevent more submissions&#10;            executor.shutdown();&#10;&#10;            // Await task completion and handle exceptions&#10;            awaitFutures(futures, executor);&#10;&#10;        } catch (IOException ioe) {&#10;            LOG.error(&quot;Copy failed, aborting from {} to {}&quot;, src, tgt, ioe);&#10;            executor.shutdownNow();&#10;            throw new IOException(&quot;Copy failed from &quot; + src + &quot; to &quot; + tgt, ioe);&#10;        } catch (RuntimeException re) {&#10;            LOG.error(&quot;Copy failed with runtime exception from {} to {}&quot;, src, tgt, re);&#10;            executor.shutdownNow();&#10;            throw new CopyFailedException(&quot;Copy failed from &quot; + src + &quot; to &quot; + tgt, re);&#10;        } finally {&#10;            if (!executor.isShutdown()) executor.shutdownNow();&#10;        }&#10;    }&#10;&#10;    private static void scheduleCopyTasks(final Path src, final Path tgt, ExecutorService executor, List&lt;Future&lt;Void&gt;&gt; futures) throws IOException {&#10;        Files.walkFileTree(src, new SimpleFileVisitor&lt;&gt;() {&#10;            @Override&#10;            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {&#10;                Path relative = src.relativize(dir);&#10;                Path targetDir = tgt.resolve(relative).normalize();&#10;                if (!targetDir.startsWith(tgt)) {&#10;                    throw new IOException(&quot;Attempt to write outside target directory: &quot; + targetDir);&#10;                }&#10;                if (!Files.exists(targetDir)) {&#10;                    Files.createDirectories(targetDir);&#10;                }&#10;                return FileVisitResult.CONTINUE;&#10;            }&#10;&#10;            @Override&#10;            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {&#10;                Path relative = src.relativize(file);&#10;                Path targetFile = tgt.resolve(relative).normalize();&#10;&#10;                if (!targetFile.startsWith(tgt)) {&#10;                    throw new IOException(&quot;Attempt to write outside target directory: &quot; + targetFile);&#10;                }&#10;&#10;                // Submit a callable that copies the file&#10;                futures.add(executor.submit(() -&gt; {&#10;                    copyFileAtomic(file, targetFile);&#10;                    return null;&#10;                }));&#10;                return FileVisitResult.CONTINUE;&#10;            }&#10;        });&#10;    }&#10;&#10;    private static void awaitFutures(List&lt;Future&lt;Void&gt;&gt; futures, ExecutorService executor) throws IOException, InterruptedException {&#10;        for (Future&lt;Void&gt; f : futures) {&#10;            try {&#10;                f.get();&#10;            } catch (ExecutionException e) {&#10;                // Cancel remaining tasks and surface the cause&#10;                executor.shutdownNow();&#10;                Throwable cause = e.getCause();&#10;                if (cause instanceof IOException ioException) {&#10;                    throw ioException;&#10;                } else if (cause instanceof RuntimeException runtimeException) {&#10;                    throw runtimeException;&#10;                } else {&#10;                    throw new IOException(&quot;Unexpected exception during file copy&quot;, cause);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Ensure termination&#10;        boolean terminated = executor.awaitTermination(5, TimeUnit.MINUTES);&#10;        if (!terminated) {&#10;            executor.shutdownNow();&#10;            throw new IOException(&quot;Timed out waiting for file copy tasks to finish&quot;);&#10;        }&#10;    }&#10;&#10;    private static void copyFileAtomic(Path sourceFile, Path targetFile) throws IOException {&#10;        Objects.requireNonNull(sourceFile);&#10;        Objects.requireNonNull(targetFile);&#10;&#10;        // Ensure parent exists&#10;        Path parent = targetFile.getParent();&#10;        if (parent == null) {&#10;            throw new IOException(&quot;Target file has no parent: &quot; + targetFile);&#10;        }&#10;        if (!Files.exists(parent)) {&#10;            Files.createDirectories(parent);&#10;        }&#10;&#10;        // Use system temp directory to avoid FS-specific limitations when creating a temp file inside the target directory.&#10;        Path temp = Files.createTempFile(&quot;filecopy-&quot;, &quot;.tmp&quot;);&#10;        boolean tempExists = true;&#10;        try {&#10;            // Write source to temp&#10;            writeSourceToTemp(sourceFile, temp);&#10;&#10;            // Move or copy temp to target; method handles fallbacks and cleanup&#10;            moveOrCopyTempToTarget(temp, sourceFile, targetFile);&#10;&#10;            // If we reach here, temp has been moved or deleted&#10;            tempExists = false;&#10;&#10;        } finally {&#10;            if (tempExists) {&#10;                safeDeleteIfExists(temp);&#10;            }&#10;        }&#10;    }&#10;&#10;    private static void moveOrCopyTempToTarget(Path temp, Path sourceFile, Path targetFile) throws IOException {&#10;        // Try an atomic move from temp -&gt; target. If not supported, fall back to regular move or copy.&#10;        try {&#10;            Files.move(temp, targetFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);&#10;            return;&#10;        } catch (UnsupportedOperationException uoe) {&#10;            LOG.debug(&quot;ATOMIC_MOVE not supported; falling back to non-atomic move: {}&quot;, uoe.toString());&#10;        } catch (IOException ioe) {&#10;            LOG.debug(&quot;Atomic move failed, will try non-atomic move or copy: {}&quot;, ioe.getMessage());&#10;        }&#10;&#10;        // Try non-atomic move&#10;        try {&#10;            Files.move(temp, targetFile, StandardCopyOption.REPLACE_EXISTING);&#10;            tryPreserveLastModifiedTime(sourceFile, targetFile);&#10;            return;&#10;        } catch (IOException moveEx) {&#10;            LOG.debug(&quot;Move from temp to target failed: {}&quot;, moveEx.getMessage());&#10;            // Fall through to final copy strategy&#10;        }&#10;&#10;        // Final fallback: copy source directly to target and then delete temp&#10;        Files.copy(sourceFile, targetFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);&#10;        safeDeleteIfExists(temp);&#10;    }&#10;&#10;    private static void tryPreserveLastModifiedTime(Path source, Path target) {&#10;        try {&#10;            Files.setLastModifiedTime(target, Files.getLastModifiedTime(source));&#10;        } catch (IOException ignored) {&#10;            LOG.debug(&quot;Could not preserve last modified time for {}&quot;, target);&#10;        }&#10;    }&#10;&#10;    private static void safeDeleteIfExists(Path path) {&#10;        try {&#10;            Files.deleteIfExists(path);&#10;        } catch (IOException delEx) {&#10;            LOG.debug(&quot;Failed to delete temp file {}: {}&quot;, path, delEx.getMessage());&#10;        }&#10;    }&#10;&#10;    private static void writeSourceToTemp(Path sourceFile, Path temp) throws IOException {&#10;        try (InputStream in = Files.newInputStream(sourceFile);&#10;             OutputStream out = Files.newOutputStream(temp)) {&#10;            byte[] buf = new byte[16 * 1024];&#10;            int r;&#10;            while ((r = in.read(buf)) != -1) {&#10;                out.write(buf, 0, r);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package de.ben;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.IOException;&#10;import java.io.InputStream;&#10;import java.io.OutputStream;&#10;import java.nio.ByteBuffer;&#10;import java.nio.channels.FileChannel;&#10;import java.nio.file.FileVisitResult;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.SimpleFileVisitor;&#10;import java.nio.file.attribute.BasicFileAttributes;&#10;import java.nio.file.StandardCopyOption;&#10;import java.nio.file.StandardOpenOption;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Objects;&#10;import java.util.concurrent.ExecutionException;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.Future;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Robust, production-ready directory &amp; file copier with focus on stability and security.&#10; */&#10;public final class FileCopy {&#10;&#10;    private static final Logger LOG = LoggerFactory.getLogger(FileCopy.class);&#10;&#10;    // Minimal size to attempt parallel copy (1 MB)&#10;    private static final long MIN_PARALLEL_SIZE = 1L * 1024L * 1024L;&#10;    // Buffer size used by chunk workers&#10;    private static final int IO_BUFFER = 64 * 1024;&#10;&#10;    private FileCopy() {&#10;        // utility class&#10;    }&#10;&#10;    /**&#10;     * Copy a source path (file or directory) to a target path using up to `threads` workers.&#10;     * If source is a directory the copy is recursive. If source is a regular file and large&#10;     * enough, a parallel chunked copy will be attempted.&#10;     */&#10;    public static void copy(Path source, Path target, int threads) throws IOException, InterruptedException {&#10;        Objects.requireNonNull(source, &quot;source&quot;);&#10;        Objects.requireNonNull(target, &quot;target&quot;);&#10;        if (threads &lt;= 0) throw new IllegalArgumentException(&quot;threads must be &gt;= 1&quot;);&#10;&#10;        Path src = source.toAbsolutePath().normalize();&#10;        Path tgt = target.toAbsolutePath().normalize();&#10;&#10;        if (!Files.exists(src)) throw new IOException(&quot;Source does not exist: &quot; + src);&#10;&#10;        if (Files.isDirectory(src)) {&#10;            copyDirectory(src, tgt, threads);&#10;            return;&#10;        }&#10;&#10;        if (Files.isRegularFile(src)) {&#10;            long size = Files.size(src);&#10;            if (threads &gt; 1 &amp;&amp; size &gt;= MIN_PARALLEL_SIZE) {&#10;                copyFileParallel(src, tgt, threads);&#10;            } else {&#10;                // reuse atomic single-file copy&#10;                copyFileAtomic(src, tgt);&#10;            }&#10;            return;&#10;        }&#10;&#10;        throw new IOException(&quot;Unsupported source type: &quot; + src);&#10;    }&#10;&#10;    /**&#10;     * Copy directory implementation (unchanged). Keep signature for backwards compatibility.&#10;     */&#10;    public static void copyDirectory(Path source, Path target, int threads) throws IOException, InterruptedException {&#10;        Objects.requireNonNull(source, &quot;source&quot;);&#10;        Objects.requireNonNull(target, &quot;target&quot;);&#10;&#10;        if (threads &lt;= 0) throw new IllegalArgumentException(&quot;threads must be &gt;= 1&quot;);&#10;&#10;        // Normalize once and bind to final locals so inner classes/lambdas can reference them&#10;        final Path src = source.toAbsolutePath().normalize();&#10;        final Path tgt = target.toAbsolutePath().normalize();&#10;&#10;        if (!Files.exists(src)) throw new IOException(&quot;Source does not exist: &quot; + src);&#10;        if (!Files.isDirectory(src)) throw new IOException(&quot;Source is not a directory: &quot; + src);&#10;&#10;        // Ensure target exists&#10;        if (!Files.exists(tgt)) {&#10;            Files.createDirectories(tgt);&#10;        }&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;        List&lt;Future&lt;Void&gt;&gt; futures = new ArrayList&lt;&gt;();&#10;&#10;        try {&#10;            // Schedule copy tasks&#10;            scheduleCopyTasks(src, tgt, executor, futures);&#10;&#10;            // Prevent more submissions&#10;            executor.shutdown();&#10;&#10;            // Await task completion and handle exceptions&#10;            awaitFutures(futures, executor);&#10;&#10;        } catch (IOException ioe) {&#10;            LOG.error(&quot;Copy failed, aborting from {} to {}&quot;, src, tgt, ioe);&#10;            executor.shutdownNow();&#10;            throw new IOException(&quot;Copy failed from &quot; + src + &quot; to &quot; + tgt, ioe);&#10;        } catch (RuntimeException re) {&#10;            LOG.error(&quot;Copy failed with runtime exception from {} to {}&quot;, src, tgt, re);&#10;            executor.shutdownNow();&#10;            throw new CopyFailedException(&quot;Copy failed from &quot; + src + &quot; to &quot; + tgt, re);&#10;        } finally {&#10;            if (!executor.isShutdown()) executor.shutdownNow();&#10;        }&#10;    }&#10;&#10;    private static void scheduleCopyTasks(final Path src, final Path tgt, ExecutorService executor, List&lt;Future&lt;Void&gt;&gt; futures) throws IOException {&#10;        Files.walkFileTree(src, new SimpleFileVisitor&lt;&gt;() {&#10;            @Override&#10;            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {&#10;                Path relative = src.relativize(dir);&#10;                Path targetDir = tgt.resolve(relative).normalize();&#10;                if (!targetDir.startsWith(tgt)) {&#10;                    throw new IOException(&quot;Attempt to write outside target directory: &quot; + targetDir);&#10;                }&#10;                if (!Files.exists(targetDir)) {&#10;                    Files.createDirectories(targetDir);&#10;                }&#10;                return FileVisitResult.CONTINUE;&#10;            }&#10;&#10;            @Override&#10;            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {&#10;                Path relative = src.relativize(file);&#10;                Path targetFile = tgt.resolve(relative).normalize();&#10;&#10;                if (!targetFile.startsWith(tgt)) {&#10;                    throw new IOException(&quot;Attempt to write outside target directory: &quot; + targetFile);&#10;                }&#10;&#10;                // Submit a callable that copies the file&#10;                futures.add(executor.submit(() -&gt; {&#10;                    copyFileAtomic(file, targetFile);&#10;                    return null;&#10;                }));&#10;                return FileVisitResult.CONTINUE;&#10;            }&#10;        });&#10;    }&#10;&#10;    private static void awaitFutures(List&lt;Future&lt;Void&gt;&gt; futures, ExecutorService executor) throws IOException, InterruptedException {&#10;        for (Future&lt;Void&gt; f : futures) {&#10;            try {&#10;                f.get();&#10;            } catch (ExecutionException e) {&#10;                // Cancel remaining tasks and surface the cause&#10;                executor.shutdownNow();&#10;                Throwable cause = e.getCause();&#10;                if (cause instanceof IOException ioException) {&#10;                    throw ioException;&#10;                } else if (cause instanceof RuntimeException runtimeException) {&#10;                    throw runtimeException;&#10;                } else {&#10;                    throw new IOException(&quot;Unexpected exception during file copy&quot;, cause);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Ensure termination&#10;        boolean terminated = executor.awaitTermination(5, TimeUnit.MINUTES);&#10;        if (!terminated) {&#10;            executor.shutdownNow();&#10;            throw new IOException(&quot;Timed out waiting for file copy tasks to finish&quot;);&#10;        }&#10;    }&#10;&#10;    private static void copyFileAtomic(Path sourceFile, Path targetFile) throws IOException {&#10;        Objects.requireNonNull(sourceFile);&#10;        Objects.requireNonNull(targetFile);&#10;&#10;        // Ensure parent exists&#10;        Path parent = targetFile.getParent();&#10;        if (parent == null) {&#10;            throw new IOException(&quot;Target file has no parent: &quot; + targetFile);&#10;        }&#10;        if (!Files.exists(parent)) {&#10;            Files.createDirectories(parent);&#10;        }&#10;&#10;        // Use system temp directory to avoid FS-specific limitations when creating a temp file inside the target directory.&#10;        Path temp = Files.createTempFile(&quot;filecopy-&quot;, &quot;.tmp&quot;);&#10;        boolean tempExists = true;&#10;        try {&#10;            // Write source to temp&#10;            writeSourceToTemp(sourceFile, temp);&#10;&#10;            // Move or copy temp to target; method handles fallbacks and cleanup&#10;            moveOrCopyTempToTarget(temp, sourceFile, targetFile);&#10;&#10;            // If we reach here, temp has been moved or deleted&#10;            tempExists = false;&#10;&#10;        } finally {&#10;            if (tempExists) {&#10;                safeDeleteIfExists(temp);&#10;            }&#10;        }&#10;    }&#10;&#10;    private static void copyFileParallel(Path source, Path target, int threads) throws IOException, InterruptedException {&#10;        Objects.requireNonNull(source);&#10;        Objects.requireNonNull(target);&#10;        if (threads &lt;= 0) throw new IllegalArgumentException(&quot;threads must be &gt;= 1&quot;);&#10;&#10;        // Ensure parent exists&#10;        Path parent = target.toAbsolutePath().normalize().getParent();&#10;        if (parent == null) throw new IOException(&quot;Target file has no parent: &quot; + target);&#10;        if (!Files.exists(parent)) Files.createDirectories(parent);&#10;&#10;        // Create temp file to write into&#10;        Path temp = Files.createTempFile(&quot;filecopy-&quot;, &quot;.tmp&quot;);&#10;        boolean tempExists = true;&#10;&#10;        // FileChannel supports positional read/write operations which are thread-safe when&#10;        // each thread uses its own ByteBuffer and specific positions (we use FileChannel.read(buf, position)&#10;        // and FileChannel.write(buf, position)). This avoids synchronization on the channel.&#10;        try (FileChannel srcCh = FileChannel.open(source, StandardOpenOption.READ);&#10;             FileChannel tgtCh = FileChannel.open(temp, StandardOpenOption.WRITE)) {&#10;&#10;            long size = srcCh.size();&#10;            long chunkSize = Math.max(MIN_PARALLEL_SIZE, (size + threads - 1) / threads);&#10;&#10;            ExecutorService executor = Executors.newFixedThreadPool(threads);&#10;            try {&#10;                List&lt;Future&lt;Void&gt;&gt; futures = new ArrayList&lt;&gt;();&#10;&#10;                for (long pos = 0; pos &lt; size; pos += chunkSize) {&#10;                    final long chunkStart = pos;&#10;                    final long chunkLen = Math.min(chunkSize, size - pos);&#10;                    futures.add(executor.submit(() -&gt; {&#10;                        ByteBuffer buf = ByteBuffer.allocate(IO_BUFFER);&#10;                        long localPos = chunkStart;&#10;                        long remaining = chunkLen;&#10;                        while (remaining &gt; 0) {&#10;                            int toRead = (int) Math.min(buf.capacity(), remaining);&#10;                            buf.limit(toRead);&#10;                            int read = srcCh.read(buf, localPos);&#10;                            if (read &lt;= 0) break;&#10;                            buf.flip();&#10;                            int written = 0;&#10;                            while (buf.hasRemaining()) {&#10;                                written += tgtCh.write(buf, localPos + written);&#10;                            }&#10;                            buf.clear();&#10;                            localPos += read;&#10;                            remaining -= read;&#10;                            if (Thread.currentThread().isInterrupted()) {&#10;                                throw new IOException(&quot;Copy interrupted&quot;);&#10;                            }&#10;                        }&#10;                        return null;&#10;                    }));&#10;                }&#10;&#10;                // Shutdown executor to stop accepting new tasks&#10;                executor.shutdown();&#10;&#10;                // wait for tasks and handle exceptions&#10;                for (Future&lt;Void&gt; f : futures) {&#10;                    try {&#10;                        f.get();&#10;                    } catch (ExecutionException e) {&#10;                        // ensure aggressive shutdown on worker failure&#10;                        executor.shutdownNow();&#10;                        Throwable cause = e.getCause();&#10;                        if (cause instanceof IOException) throw (IOException) cause;&#10;                        if (cause instanceof RuntimeException) throw (RuntimeException) cause;&#10;                        throw new IOException(&quot;Unexpected exception during parallel file copy&quot;, cause);&#10;                    }&#10;                }&#10;&#10;                boolean terminated = executor.awaitTermination(5, TimeUnit.MINUTES);&#10;                if (!terminated) {&#10;                    executor.shutdownNow();&#10;                    throw new IOException(&quot;Timed out waiting for parallel copy tasks to finish&quot;);&#10;                }&#10;&#10;                // Move temp to final target (attempt atomic)&#10;                try {&#10;                    Files.move(temp, target, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);&#10;                } catch (IOException e) {&#10;                    // try non-atomic move as fallback&#10;                    try {&#10;                        Files.move(temp, target, StandardCopyOption.REPLACE_EXISTING);&#10;                    } catch (IOException moveEx) {&#10;                        // final fallback: copy original source to target&#10;                        Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);&#10;                        safeDeleteIfExists(temp);&#10;                        return;&#10;                    }&#10;                }&#10;&#10;                // preserve last modified&#10;                tryPreserveLastModifiedTime(source, target);&#10;                tempExists = false;&#10;&#10;            } finally {&#10;                // Ensure executor is shutdown to avoid thread leaks&#10;                if (!executor.isShutdown()) {&#10;                    executor.shutdownNow();&#10;                }&#10;            }&#10;&#10;        } finally {&#10;            if (tempExists) safeDeleteIfExists(temp);&#10;        }&#10;    }&#10;&#10;    private static void moveOrCopyTempToTarget(Path temp, Path sourceFile, Path targetFile) throws IOException {&#10;        // Try an atomic move from temp -&gt; target. If not supported, fall back to regular move or copy.&#10;        try {&#10;            Files.move(temp, targetFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);&#10;            return;&#10;        } catch (UnsupportedOperationException uoe) {&#10;            LOG.debug(&quot;ATOMIC_MOVE not supported; falling back to non-atomic move: {}&quot;, uoe.toString());&#10;        } catch (IOException ioe) {&#10;            LOG.debug(&quot;Atomic move failed, will try non-atomic move or copy: {}&quot;, ioe.getMessage());&#10;        }&#10;&#10;        // Try non-atomic move&#10;        try {&#10;            Files.move(temp, targetFile, StandardCopyOption.REPLACE_EXISTING);&#10;            tryPreserveLastModifiedTime(sourceFile, targetFile);&#10;            return;&#10;        } catch (IOException moveEx) {&#10;            LOG.debug(&quot;Move from temp to target failed: {}&quot;, moveEx.getMessage());&#10;            // Fall through to final copy strategy&#10;        }&#10;&#10;        // Final fallback: copy source directly to target and then delete temp&#10;        Files.copy(sourceFile, targetFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);&#10;        safeDeleteIfExists(temp);&#10;    }&#10;&#10;    private static void tryPreserveLastModifiedTime(Path source, Path target) {&#10;        try {&#10;            Files.setLastModifiedTime(target, Files.getLastModifiedTime(source));&#10;        } catch (IOException ignored) {&#10;            LOG.debug(&quot;Could not preserve last modified time for {}&quot;, target);&#10;        }&#10;    }&#10;&#10;    private static void safeDeleteIfExists(Path path) {&#10;        try {&#10;            Files.deleteIfExists(path);&#10;        } catch (IOException delEx) {&#10;            LOG.debug(&quot;Failed to delete temp file {}: {}&quot;, path, delEx.getMessage());&#10;        }&#10;    }&#10;&#10;    private static void writeSourceToTemp(Path sourceFile, Path temp) throws IOException {&#10;        try (InputStream in = Files.newInputStream(sourceFile);&#10;             OutputStream out = Files.newOutputStream(temp)) {&#10;            byte[] buf = new byte[16 * 1024];&#10;            int r;&#10;            while ((r = in.read(buf)) != -1) {&#10;                out.write(buf, 0, r);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>